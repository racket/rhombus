#lang rhombus
import:
  "version_guard.rhm"

block:
  import "static_arity.rhm"
  static_arity.check:
    Bytes.make(n, [b])
    Bytes.length(bstr) ~method
    Bytes.get(bstr, i) ~method
    Bytes.set(bstr, i, b) ~method
    Bytes.append(bstr, ...) ~method
    Bytes.subbytes(bstr, start, [end]) ~method
    Bytes.copy(bstr) ~method
    Bytes.copy_from(dest_bstr, dest_start, src_bstr, [src_start], [src_end]) ~method
    Bytes.snapshot(bstr) ~method
    Bytes.utf8_string(bstr, [err_ch], [start], [end]) ~method
    Bytes.latin1_string(bstr, [err_ch], [start], [end]) ~method
    Bytes.locale_string(bstr, [err_ch], [start], [end]) ~method
    Bytes.to_sequence(bstr) ~method

check:
  #"hello" :: Bytes ~is #"hello"

block:
  use_static
  check:
    def hello = #"hello"
    hello.length()
    ~is 5
  check:
    #"hello".length() ~is 5
    #"hello"[0] ~is 104
    #"hello".get(0) ~is 104
    #"hello" ++ #" " ++ #"world" ~is_now #"hello world"
    #"hello" ++ #" " ++ "world" ~throws values(
      "Bytes.append: contract violation",
      "expected: Bytes",
      "given: \"world\"",
    )
    #"hello".append(#" world") ~is_now #"hello world"
    #"hello".append(#" world", #" and bye") ~is_now #"hello world and bye"
    #"hello".subbytes(1) ~is_now #"ello"
    #"hello".subbytes(1, 4) ~is_now #"ell"
    #"hello".copy() ~is_now #"hello"
    #"hello".copy() == #"hello" ~is #false
    (block:
       let s = #"hello".copy()
       s.copy_from(0, #"HE")
       s) ~is_now #"HEllo"
    (block:
       let s = #"hello".copy()
       s.copy_from(2, #"xxxx", 1, 3)
       s) ~is_now #"hexxo"
    #"hello".snapshot() ~is #"hello".snapshot()
    #"hello".snapshot() == #"hello" ~is #true
    #"h\303\211llo".utf8_string() ~is "hÉllo"
    #"h\303\211llo".utf8_string(#false, 3) ~is "llo"
    #"h\311llo".latin1_string() ~is "hÉllo"
    #"hello".locale_string() ~is "hello"
    #"h\303\211llo".utf8_string().length() ~is 5

check:
  dynamic(#"hello").length() ~is 5
  dynamic(#"hello")[0] ~is 104
  dynamic(#"hello" ++ #" ") ++ #"world" ~is_now #"hello world"
  dynamic(#"hello" ++ #" ") ++ "world" ~throws "cannot append a byte string and other value"
  dynamic(#"hello").append(#" world") ~is_now #"hello world"
  dynamic(#"hello").append(#" world", #" and bye") ~is_now #"hello world and bye"
  dynamic(#"hello").get(0) ~is 104
  dynamic(#"hello").subbytes(1) ~is_now #"ello"
  dynamic(#"hello").subbytes(1, 4) ~is_now #"ell"
  dynamic(#"hello").copy() ~is_now #"hello"
  (block:
     let s = #"hello".copy()
     dynamic(s).copy_from(0, #"HE")
     s) ~is_now #"HEllo"
  dynamic(#"hello").snapshot() ~is #"hello"
  dynamic(#"h\303\211llo").utf8_string() ~is "hÉllo"
  dynamic(#"h\303\211llo").utf8_string(#false, 3) ~is "llo"
  dynamic(#"h\311llo").latin1_string() ~is "hÉllo"
  dynamic(#"hello").locale_string() ~is "hello"

block:
  use_static
  def bstr = #"hello".copy()
  bstr[1] := 104
  bstr.set(2, 104)
  check bstr ~is_now #"hhhlo"
  block:
    use_dynamic
    dynamic(bstr)[3] := 104
    dynamic(bstr).set(4, 104)
    check bstr ~is_now #"hhhhh"

check:
  Bytes.append() ~is_now #""
  Bytes.append(#"this".copy()) ~is_now #"this"
  Bytes.append(#"this".copy(), #", that".copy()) ~is_now #"this, that"
  Bytes.append(#"this".copy(), #" and ", #"that".copy()) ~is_now #"this and that"
  Bytes.append(#"this".copy(), #", this", #", and ", #"that".copy()) ~is_now #"this, this, and that"

check:
  Bytes.length(#"hello") ~is 5
  Bytes.subbytes(#"hello", 1) ~is_now #"ello"
  Bytes.subbytes(#"hello", 1, 4) ~is_now #"ell"
  Bytes.copy(#"hello") ~is_now #"hello"
  Bytes.utf8_string(#"h\303\211llo") ~is "hÉllo"
  Bytes.utf8_string(#"h\303\211llo", #false, 3) ~is "llo"
  Bytes.latin1_string(#"h\311llo") ~is "hÉllo"
  Bytes.locale_string(#"hello") ~is "hello"

check:
  to_string(#"hello") ~is "hello"
  to_string(#"hello".copy()) ~is "hello"
  to_string(#"hello", ~mode: #'expr) ~is "#\"hello\""
  to_string(#"hello".copy(), ~mode: #'expr) ~is "Bytes.copy(#\"hello\")"

block:
  use_static
  def bstr = #"123"
  check:
    for List (x: bstr):
      x
    ~is [49, 50, 51]
  check:
    for List (x: Bytes.to_sequence(bstr)):
      x
    ~is [49, 50, 51]
  check:
    for List (x: bstr.to_sequence()):
      x
    ~is [49, 50, 51]

version_guard.at_least "8.13.0.1":
  check:
    Bytes.to_sequence("oops")
    ~throws values(
      "Bytes.to_sequence: contract violation",
      "expected: Bytes",
      "given: \"oops\"",
    )
  check:
    ("oops" :~ Bytes).to_sequence()
    ~throws values(
      "Bytes.to_sequence: contract violation",
      "expected: Bytes",
      "given: \"oops\"",
    )
  check:
    for List (x: "oops" :~ Bytes):
      x
    ~throws values(
      "Bytes.to_sequence: contract violation",
      "expected: Bytes",
      "given: \"oops\"",
    )
  check:
    for List (x: Bytes.to_sequence("oops")):
      x
    ~throws values(
      "Bytes.to_sequence: contract violation",
      "expected: Bytes",
      "given: \"oops\"",
    )
  check:
    for List (x: ("oops" :~ Bytes).to_sequence()):
      x
    ~throws values(
      "Bytes.to_sequence: contract violation",
      "expected: Bytes",
      "given: \"oops\"",
    )

check:
  ("oops" :~ Bytes)[0]
  ~throws values(
    "Bytes.get: contract violation",
    "expected: Bytes",
    "given: \"oops\"",
  )

check:
  ("oops" :~ MutableBytes)[0] := 0
  ~throws values(
    "Bytes.set: contract violation",
    "expected: MutableBytes",
    "given: \"oops\"",
  )
