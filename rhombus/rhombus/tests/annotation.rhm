#lang rhombus

check:
  1 is_a Int ~is #true
  1 !is_a Int ~is #false
  1 !is_a Flonum ~is #true
  1 is_a !Int ~is #false
  1 is_a !Flonum ~is #true

// check for sensible precedence of `is_a` mixed with expression
check:
  "a" is_a String && #true ~is #true
  "a" is_a String +& "ok" ~is "#trueok"

// check for different precedence of `::`, especially intended
// for bindings
check:
  ~eval
  "a" :: String && #true
  ~throws  "literal not allowed as an annotation"
check:
  ("a" :: String) && #true ~is #true
  (block:
     def x :: String || Int = "ok"
     x) ~is "ok"
  (block:
     def x :: String || Int = 5
     x) ~is 5

check:
  ~eval
  "a" is_a PosInt . count()
  ~throws "operators with inconsistently declared precedence"

check:
  0 :: converting(fun (i :: Int when i mod 3 == 0): i)
  1 :: converting(fun (i :: Int unless i mod 3 == 0): i)
  [1, 2, 3] :: converting(fun ([x, ...] when math.sum(x, ...) == 6): #true)
  ~completes

check:
  0 is_a converting(fun (i :: Int when i mod 3 == 0): i)
  1 is_a converting(fun (i :: Int unless i mod 3 == 0): i)
  [1, 2, 3] is_a converting(fun ([x, ...] when math.sum(x, ...) == 6): #true)
  ~completes

block:
  fun is_multiple_of(n):
    fun (v):
      v is_a Int && v mod n == 0
  check:
    0 ~is_a satisfying(is_multiple_of(1))
    1 ~is_a satisfying(is_multiple_of(1))
    15 ~is_a satisfying(is_multiple_of(3)) && satisfying(is_multiple_of(5))

check:
  #false is_a satisfying("not a function")
  ~throws values(error.annot_msg(), error.annot("Function.of_arity(1)").msg)

check:
  #false is_a satisfying(fun (): #false)
  ~throws values(error.annot_msg(), error.annot("Function.of_arity(1)").msg)


block:
  check:
    def List(_) :: List = [1]
    ~completes
  check:
    def List(_, _, _) :: List = [1]
    #void
    ~throws values(
      "value does not satisfy annotation",
      "[1]",
      "List && matching(List(_, _, _))",
    )

check:
  def List(_, _, _) :: satisfying(fun (_): error("oops")) = [1]
  #void
  ~throws "oops"

block:
  import:
    rhombus/meta open
  annot.macro 'one_to_two':
    ~all_stx: self
    '(converting(fun ([x]): [x, x]))'.relocate_span([self])
  check:
    def List(_, _) :: one_to_two = [1]
    ~completes
  check:
    def List(_, _) :: one_to_two = [1, 2]
    #void
    ~throws values(
      "value does not satisfy annotation",
      "[1, 2]",
      "one_to_two && matching(List(_, _))",
    )
  check:
    def List(_, _, _) :: one_to_two = [1]
    #void
    ~throws values(
      "value does not satisfy annotation",
      "[1]",
      "one_to_two && matching(List(_, _, _))",
    )

check:
  def List(_, _, _) :: converting(fun (_): error("oops")) = [1]
  #void
  ~throws "oops"

check:
  "x" :: (False || ((converting(fun (v): [v]) && True) || False))
  ~is ["x"]

check:
  "x" :: !converting(fun (_ :: !String): error("oops"))
  ~is "x"

check:
  #false :: False ~is #false
  "x" :: True ~is "x"
  "x" :: False ~throws "does not satisfy"
  #false :: True ~throws "does not satisfy"

check:
  #true :: Any ~is #true
  #true :: Any.of(#true, #false) ~is #true
  #true :: Any.to_boolean ~is #true
  #true :: None ~throws "does not satisfy"
  #false :: Any ~is #false
  #false :: Any.of(#true, #false) ~is #false
  #false :: Any.to_boolean ~is #false
  #false :: None ~throws "does not satisfy"
  "x" :: Any ~is "x"
  "x" :: Any.of(#true, #false) ~throws "does not satisfy"
  "x" :: Any.to_boolean ~is #true
  "x" :: None ~throws "does not satisfy"

block:
  namespace ns:
    export:
      Int
      Array
      Posn
    class Posn(x, y)
  check "a" :: ns.Int ~throws "ns.Int"
  check "a" :: ns.Array ~throws "ns.Array"
  check "a" :: ns.Array.of_length(10) ~throws "ns.Array.of_length(10)"
  check "a" :: ns.Posn ~throws "ns.Posn"

block:
  use_static
  let [x, ...] = [[], [2, 3], [4, 5, 6]]
  check [x is_a List, ...] ~is [#true, #true, #true]
  check [x is_a NonemptyList, ...] ~is [#false, #true, #true]
  check [x is_a Int, ...] ~is [#false, #false, #false]
  check [x !is_a List, ...] ~is [#false, #false, #false]
  check [x !is_a NonemptyList, ...] ~is [#true, #false, #false]
  check [x :: List, ...] ~is [[], [2, 3], [4, 5, 6]]
  check [(x :: List).length(), ...] ~is [0, 2, 3]
  check [x :~ List, ...] ~is [[], [2, 3], [4, 5, 6]]
  check [(x :~ List).length(), ...] ~is [0, 2, 3]

check:
  fun f(x :: Any.of(block: println("now"); 1),
        ...):
    #'ok
  f(1, 1)
  f()
  f(1, 1, 1, 1, 1)
  ~prints "now\nnow\nnow\n"

block:
  fun f(x :: Real.in(0, block:
                          println("now")
                          10),
        ...):
    "ok"
  check f() ~prints "now\n"
  check f(0) ~prints "now\n"
  check f(0, 1) ~prints "now\n"

block:
  fun f(x :: satisfying(block:
                          println("now")
                          fun (x): #true),
        ...):
    "ok"
  check f() ~prints "now\n"
  check f(0) ~prints "now\n"
  check f(0, 1) ~prints "now\n"
