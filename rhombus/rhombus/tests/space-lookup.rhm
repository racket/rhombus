#lang rhombus/and_meta

space.transform food:
  space_path rhombus/example/food
  bridge_definer bridge
  meta_namespace food_meta:
    reflection space
    name_start_syntax_class NameStart
    bound_name_start_syntax_class BoundNameStart

check:
  food.bridge cake:
    "pineapple upsidedown"
  expr.macro 'go':
    '$(syntax_meta.value('cake', food_meta.space))'
  go
  ~is "pineapple upsidedown"

check:
  namespace bakery:
    export cake
    food.bridge cake:
      "chocolate"
  expr.macro 'go':
    '$(syntax_meta.value('bakery.cake', food_meta.space))'
  go
  ~is "chocolate"

block:
  namespace bakery:
    export cake
    food.bridge cake:
      "chocolate"
  expr.macro 'go $(seq :: food_meta.NameStart) $()':
    '[$(syntax_meta.value(seq.name, food_meta.space, fun (): '#false')),
      '$seq.tail ...']'
  expr.macro
  | 'bound_go $(seq :: food_meta.BoundNameStart) $()':
      '[$(syntax_meta.value(seq.name, food_meta.space, fun (): '#false')),
        '$seq.tail ...']'
  | 'bound_go $other ...':
      '[#'unbound,
        '$other ...']'
  check: go bakery.cake + icing
         ~matches ["chocolate", '+ icing']
  check: go bakery.cake.to.go
         ~matches ["chocolate", '. to . go']
  check: go non_cake.to.go
         ~matches [#false, '. to . go']
  check: bound_go bakery.cake + icing
         ~matches ["chocolate", '+ icing']
  check: bound_go bakery.cake.to.go
         ~matches ["chocolate", '. to . go']
  check: bound_go non_cake.to.go
         ~matches [#'unbound, 'non_cake . to . go']

check:
  food.bridge List.cake:
    "tiered"
  expr.macro 'go':
    '$(syntax_meta.value('List.cake', food_meta.space))'
  go
  ~is "tiered"
