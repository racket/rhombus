#lang rhombus/static/and_meta
import:
  lib("racket/gui/easy.rkt")
  rhombus/draw:
    expose:
      Color
      Font
  rhombus/draw/private/font!private._Font
  rhombus/draw/private/symbol_map.symbol_map_annot
  "label.rhm".Label.normal_control_font
  "obs.rhm":
    expose:
      Obs
      ObsOrValue
  "view.rhm".View
  "view.rhm"!private.BaseWindowView
  "view-help.rkt"

export:
  Table
  ListChoice

class Table(private _at_selection :: Obs):
  extends BaseWindowView

  constructor (columns :: List.of(View.LabelString),
               entries :: ObsOrValue.of(Array),
               ~action: callback :: (Table.Event, Array, Table.Selection) -> ~any = values,
               ~choice_to_row: entry_to_row :: Any -> Array.now_of(View.LabelString) = values,
               ~selection: selection :: ObsOrValue.of(Table.Selection) = #false,
               ~label: label :: ObsOrValue.of(View.LabelString) = "",
               ~is_enabled: is_enabled :: ObsOrValue.of(Boolean) = #true,
               ~style: style :: ObsOrValue.of(List.of(Table.StyleSymbol))
                         = [#'single, #'column_headers, #'clickable_headers, #'reorderable_headers],
               ~font : font :: Font = normal_control_font,
               ~margin: margin :: ObsOrValue.of(View.Margin) = [2, 2],
               ~min_size: min_size :: ObsOrValue.of(View.Size) = [#false, #false],
               ~stretch: stretch :: ObsOrValue.of(View.Stretch) = [#true, #false],
               ~column_widths: column_widths :: ObsOrValue.of(List.of(Table.CellWidth))
                                 = []):
    let at_selection = obs.to_obs(selection)
    #{view-help}.#{mix-wrap}(
      fun (mix):
        super(easy.table(obs.unwrap_list(columns, values),
                         obs.unwrap(entries),
                         fun (a, row, sel):
                           callback(a, row, unconvert_selection(sel)),
                         ~#{entry->row}: entry_to_row,
                         ~selection: obs.unwrap_convert(selection, convert_selection),
                         ~label: obs.unwrap(label),
                         ~#{enabled?}: obs.unwrap(is_enabled),
                         ~style: obs.unwrap_list(style, convert_style),
                         ~font: obs.unwrap_convert(font, fun (f): f && (f :~ Font).handle),
                         ~margin: obs.unwrap_list(margin, values),
                         ~#{min-size}: obs.unwrap_list(min_size, values),
                         ~stretch: obs.unwrap_list(stretch, values),
                         ~#{column-widths}: obs.unwrap_list(column_widths, fun (v): obs.unwrap_list(v, values)),
                         ~mixin: mix))
          <| (at_selection)
    )

  property at_selection :: Obs:
    _at_selection.map(values)

  export:
    Selection
    CellWidth
    StyleSymbol
    Event

  annot.macro 'Selection':
    'maybe(Int || List.of(Int))'

  fun convert_selection(v):
    match v
    | PairList[i, ...]: [i, ...]
    | ~else: v

  fun unconvert_selection(v):
    match v
    | [i, ...]: PairList[i, ...]
    | ~else: v

  annot.macro 'CellWidth':
    '[Int, View.SizeInt] || [Int, View.SizeInt, View.SizeInt, View.SizeInt]'

  symbol_map_annot StyleSymbol convert_style
  | single
  | multiple
  | extended
  | variable_columns = #{variable-columns}
  | column_headers = #{column-headers}
  | clickable_headers = #{clickable-headers}
  | reorderable_headers = #{reorderable-headers}
  | horizontal_label = #{horizontal-label}
  | vertical_label = #{vertical-label}
  | deleted

  symbol_map_annot Event convert_action unconvert_action
  | select
  | double_click = dclick
  | column

class ListChoice(private _at_selection :: Obs):
  extends BaseWindowView

  constructor (choices :: ObsOrValue.of(List),
               ~action: callback :: Any -> ~any = values,
               ~choice_to_label: choice_to_label :: Any -> Any = values,
               ~choice_equal: choice_equal :: Function.of_arity(2) = fun (a, b): a == b,
               ~selection: selection :: ObsOrValue.of(Any) = #false,
               ~label: label :: ObsOrValue.of(View.LabelString) = "",
               ~is_enabled: is_enabled :: ObsOrValue.of(Boolean) = #true,
               ~style: style :: ObsOrValue.of(List.of(ListChoice.StyleSymbol)) = [],
               ~font : font :: Font = normal_control_font,
               ~margin: margin :: ObsOrValue.of(View.Margin) = [2, 2],
               ~min_size: min_size :: ObsOrValue.of(View.Size) = [#false, #false],
               ~stretch: stretch :: ObsOrValue.of(View.Stretch) = [#true, #false]):
    let at_selection = obs.to_obs(selection)
    #{view-help}.#{mix-wrap}(
      fun (mix):
        super(easy.table(PairList["value"],
                         obs.unwrap_convert(choices, fun ([v, ...]): Array(v, ...)),
                         fun (a, choices, sel):
                           callback(#//a, unconvert_selection(choices, sel), #//sel),
                         ~#{entry->row}: fun (v): Array(choice_to_label(v)),
                         ~selection: obs.unwrap_convert(selection, fun (sel): convert_selection(choices, choice_equal, sel)),
                         ~label: obs.unwrap(label),
                         ~#{enabled?}: obs.unwrap(is_enabled),
                         ~style: obs.unwrap_convert(style, fun (l): Pair.cons(#'single, obs.unwrap_list(l, convert_style))),
                         ~font: obs.unwrap_convert(font, fun (f): f && (f :~ Font).handle),
                         ~margin: obs.unwrap_list(margin, values),
                         ~#{min-size}: obs.unwrap_list(min_size, values),
                         ~stretch: obs.unwrap_list(stretch, values),
                         ~mixin: mix))
          <| (at_selection)
    )

  property at_selection :: Obs:
    _at_selection.map(values)

  export:
    StyleSymbol

  fun unconvert_selection(choices, i):
    fun ref(choices, i :: Int):
      match choices
      | choices :: Array: (i < choices.length()) && choices[i]
      | choices :: Obs: ref(choices.value, i)
    i && ref(choices,  i)

  fun convert_selection(choices, choice_equal, v):
    match choices
    | choices :: List: choices.index(v, choice_equal)
    | choices :: Obs: convert_selection(choices.value, choice_equal, v)

  symbol_map_annot StyleSymbol convert_style
  | horizontal_label = #{horizontal-label}
  | vertical_label = #{vertical-label}
  | deleted
