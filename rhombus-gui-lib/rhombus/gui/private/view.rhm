#lang rhombus/static/and_meta
import:
  rhombus/rkt_obj
  lib("racket/gui/easy.rkt"):
    expose:
      #{if-view}
      #{cond-view}
      #{observable-view}
  lib("racket/base.rkt").else
  "obs.rhm"
  "type.rhm"
  "renderer.rhm".Renderer
  "renderer.rhm"!private._Renderer

export:
  View
  WindowView
  WindowChildView
  MenuChildView
  PopupMenuView
  render

module private:
  export:
    BaseView
    WindowViewI
    BaseWindowView
    PopupMenuView
    MenuChildViewI
    to_view
    set_view_gui_handle
    get_gui_handle_view

interface View:
  implementable ViewI
  property handle
  property gui_handle

  method get_gui_handle(who = #false):
    gui_handle || error(~who: who, "view is not currently rendered")

  export:
    if
    cond
    all_from(.type.View)

  expr.macro 'if $test | $then | $else':
    'AView($(expr_meta.pack_s_exp(['#{if-view}',
                                   expr_meta.pack_expr('obs.unwrap(block: $test)'),
                                   expr_meta.pack_expr('unwrap_view(block: $then)'),
                                   expr_meta.pack_expr('unwrap_view(block: $else)')])))'

  expr.macro
  | 'cond
     | $ques ...: $ans
     | ...
     | ~else: $else_ans':
      'AView($(expr_meta.pack_s_exp(['#{cond-view}',
                                     [expr_meta.pack_expr('obs.unwrap($ques ...)'),
                                      expr_meta.pack_expr('unwrap_view(block: $ans)')],
                                     ...,
                                     ['else',
                                      expr_meta.pack_expr('unwrap_view(block: $else_ans)')]])))'
  | 'cond
     | $ques ...: $ans
     | ...
     | ~else $else':
      'cond
       | $ques ...: $ans
       | ...
       | ~else: $else'

interface PopupMenuView:
  extends ViewI

interface WindowChildView:
  implementable WindowChildViewI
  extends ViewI

  private method get_renderer_handle(who = #false):
    let gui_handle = get_gui_handle(who)
    let root_handle = rkt_obj.send gui_handle.#{get-top-level-window}()
    let r_handle = root_handle_to_renderer_handle.maybe[root_handle]
    r_handle || error(~who: who, "view is not currently rendered")

  method client_to_screen(
    x :: View.PositionInt,
    y :: View.PositionInt
  ) :~ values(View.PositionInt, View.PositionInt):
    ~who: who
    rkt_obj.send get_gui_handle(who).#{client->screen}(x, y)

  method screen_to_client(
    x :: View.PositionInt,
    y :: View.PositionInt
  ) :~ values(View.PositionInt, View.PositionInt):
    ~who: who
    rkt_obj.send get_gui_handle(who).#{screen->client}(x, y)

  method popup(
    pu :: PopupMenuView described_as PopupMenu,
    x :: View.PositionInt,
    y :: View.PositionInt
  ):
    ~who: who
    let r_handle = get_renderer_handle(who)
    let win_handle = easy.#{renderer-root}(r_handle)
    let (x, y) = client_to_screen(x, y)
    let (x, y) = rkt_obj.send win_handle.#{screen->client}(x, y)
    easy.#{render-popup-menu}(r_handle, pu.handle, x, y)

  method focus():
    ~who: who
    rkt_obj.send get_gui_handle(who).#{focus}()

interface WindowView:
  implementable WindowViewI
  extends WindowChildViewI
  method show(on):
    ~who: who
    rkt_obj.send get_gui_handle(who).#{show}(on)

  method render(parent :: maybe(Renderer) = #false) :: Renderer:
    let r = _Renderer(easy.render(handle, parent?.handle, ~#{wait?}: #false))
    root_handle_to_renderer_handle[easy.#{renderer-root}(r.handle)] := r.handle
    r

  method run(parent :: maybe(Renderer) = #false):
    easy.render(handle, parent?.handle, ~#{wait?}: #true)

def root_handle_to_renderer_handle :~ MutableMap = WeakMutableMap()

fun render(view :: WindowView,
           parent :: maybe(Renderer) = #false) :: Renderer:
  view.render(parent)

interface MenuChildView:
  implementable MenuChildViewI
  extends ViewI

fun unwrap_view(v :: View): v.handle

class BaseView(private _handle):
  nonfinal
  implements ViewI
  internal _BaseView
  override property handle: _handle

  constructor (hand):
    super(hand)

  private field _gui_handle = #false
  override property gui_handle: _gui_handle

class BaseWindowView():
  nonfinal
  extends BaseView
  implements WindowChildViewI

  constructor (hand):
    super(hand)()

class AView(private _handle):
  implements ViewI
  internal _AView
  override property handle: _handle

  private field _gui_handle = #false
  override property gui_handle: _gui_handle

  constructor (hand):
    super(hand)

  private implements Printable
  private override describe(mode, recur):
    PrintDesc.list("View(", [], ")")

fun
| to_view(v :: View) :: View: v
| to_view(o :: obs.Obs) :: View: AView(#{observable-view}(o.map(fun (v :: View): v.handle).handle))

def gui_handle_to_view = WeakMutableMap()

fun set_view_gui_handle(v :~ _BaseView, gui_handle):
  v._gui_handle := gui_handle
  gui_handle_to_view[gui_handle] := v

fun get_gui_handle_view(gui_handle):
  gui_handle_to_view.maybe[gui_handle]
    || (block:
          let p = rkt_obj.send gui_handle.#{get-parent}()
          p && get_gui_handle_view(p))
