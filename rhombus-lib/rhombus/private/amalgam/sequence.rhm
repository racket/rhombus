#lang rhombus/private/amalgam/core
import:
  "core-meta.rkt" open
  lib("racket/base.rkt")
  meta:
    lib("enforest/deprecated.rkt")

use_static

export:
  Sequence

fun is_sequence(v):
  base.#{sequence?}(v) && (v !is_a Int)

annot.macro 'Sequence':
  annot_meta.pack_predicate('is_sequence',
                            '(($statinfo_meta.sequence_constructor_key, #true))')

namespace Sequence:
  export:
    make
    instantiable
    instantiate
    generate
    to_stream
    assume_of
    expect_of
  annot.macro 'expect_of($(ann :: Group), ...)':
    deprecated.#{warn-deprecated!}(#'#{Sequence.expect_of}, "15-MAR-2026")
    'assume_of($ann, ...)'
  annot.macro 'assume_of($(ann :: Group), ...)':
    ~all_stx: stx
    ~context: ctx
    let ['$(a :: annot_meta.Parsed(ctx))', ...] = [ann, ...]
    let [statinfos, ...]:
      for List (a in [a, ...]):
        if annot_meta.is_converter(a)
        | syntax_meta.error("converter annotation not supported for elements", stx, a)
        | let (_, statinfos) = annot_meta.unpack_predicate(a)
          statinfos
    let all_statinfos:
      let l = [statinfos, ...]
      if l.length() == 1
      | l[0]
      | '(($statinfo_meta.values_key, $(statinfo_meta.pack_group('$statinfos ...'))))'
    annot_meta.pack_predicate('is_sequence',
                              '(($statinfo_meta.sequence_constructor_key, #true),
                                ($statinfo_meta.sequence_element_key, $(statinfo_meta.pack(all_statinfos))))',
                              ~track: [a, ...])

fun make(~initial_position: init_pos,
         ~continue_at_position: continue_at_pos = #false,
         ~continue_at_value: continue_at_val = #false,
         ~early_position_to_next: early_next_pos = #false,
         ~position_to_element: pos_to_element,
         ~continue_after_position_and_value: continue_at_pos_val = #false,
         ~position_to_next: next_pos) :~ Sequence:
  ~name: Sequence.make
  base.#{make-do-sequence}(
    fun ():
      values(pos_to_element,
             early_next_pos,
             next_pos,
             init_pos,
             continue_at_pos,
             continue_at_val,
             continue_at_pos_val)
  )

fun instantiable(thunk) :~ Sequence:
  ~name: Sequence.instantiable
  base.#{make-do-sequence}(thunk)

fun instantiate(~initial_position: init_pos,
                ~continue_at_position: continue_at_pos = #false,
                ~continue_at_value: continue_at_val = #false,
                ~early_position_to_next: early_next_pos = #false,
                ~position_to_element: pos_to_element,
                ~continue_after_position_and_value: continue_at_pos_val = #false,
                ~position_to_next: next_pos):
  ~name: Sequence.instantiate
  values(pos_to_element,
         early_next_pos,
         next_pos,
         init_pos,
         continue_at_pos,
         continue_at_val,
         continue_at_pos_val)

fun generate(seq :: Sequence) :~ values(Function.of_arity(0), Function.of_arity(0)):
  ~name: Sequence.instantiate
  base.#{sequence-generate}(seq)

fun to_stream(seq :: Sequence) :~ Stream.assume_of(Any.like_element(seq)):
  base.#{sequence->stream}(seq)
